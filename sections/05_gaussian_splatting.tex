\section{Gaussian Splatting}
\subsection{Point-Based Splatting Surfels}
Belong to traditional point-based graphics methods.

\textbf{Definition}
Surfels (surface elements) are 3D points that approximate local surface patches.
\begin{itemize}
	\item position $(x, y, z)$,
	\item a surface normal,
	\item a radius for disc size,
	\item color and optional confidence.
\end{itemize}


\textbf{Rendering Principle:}
\begin{enumerate}
	\item Project each surfel center into the camera.
	\item Render its elliptical footprint.
	\item Blend footprints in depth order (front to back): Gaussian kernel.
	\item Moving the camera closer scales the discs accordingly.
\end{enumerate}

\textbf{Advantages:}
\begin{itemize}
	\item No mesh connectivity required.
	\item Robust to noisy or incomplete geometry.
	\item Projection step of each point into image can be parallelized.
	\item (Almost) real-time rendering feasible.
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
	\item Limited handling of transparency.
	\item Not volumetric; represents only surfaces.
	\item Blending requires heuristics and is not fully differentiable.
\end{itemize}

\subsection{Gaussian Splatting}

\textbf{3D Gaussian Splatting} represents a scene with 3D Gaussian blobs.
Each Gaussian is defined by:
\begin{itemize}
	\item mean (3D center),
	\item covariance matrix (shape, scale, and orientation),
	\item color (often represented by spherical harmonics),
	\item opacity.
\end{itemize}

\textbf{Spherical Harmonics}:
\begin{itemize}
	\item Are a family of smooth, wave-like functions defined on the surface of a sphere.
	\item Used to capture view-dependent color variations.
	\item Instead of storing a single RGB color, each Gaussian stores coefficients for spherical harmonics.
\end{itemize}

\begin{center}
	\includegraphics[width=0.5\columnwidth]{images/spherical_harmonics.jpeg}
	\label{fig:spherical_harmonics}
\end{center}

\textbf{Overview}
\begin{center}
	\includegraphics[width=\columnwidth]{images/gaussian_splatting.jpeg}
	\label{fig:gaussian_splatting}
\end{center}

\begin{itemize}
	\item \textbf{Initialization}: sparse structure from motion points are converted into 3D Gaussians
	\item \textbf{Rendering Loop}: \begin{itemize}
		      \item The camera defines the viewpoint for rendering
		      \item 3D Gaussians are projected into 2D image space
	      \end{itemize}
	\item \textbf{Differentiable Tile Rasterer}: \begin{itemize}
		      \item Sort Gaussians by depth
		      \item Split screen into tiles for efficient rendering ($16 \times 16$ tiles)\\
		            This GPU to process tiles in sharded-memory instead of reading all Gaussians from global VRAM.
		      \item Alpha-blending: Blend Gaussians front-to-back using their opacities
		      \item Fully differentiable: allows gradient-based optimization
	      \end{itemize}
	\item \textbf{Optimization}: \begin{itemize}
		      \item There is no neural network involved, optimization is performed directly on Gaussian parameters.
		      \item Compare rendered image to ground truth: Photometric Loss
		      \item Multi-view constraint: use multiple images from different viewpoints
		      \item Backpropagate errors to update Gaussian parameters (position, shape, color, opacity)
		      \item To get a valid covariance matrix, optimize its decomposition $\Sigma = RSS^TR^T$
	      \end{itemize}
	\item \textbf{Adaptive Density Control}: \begin{itemize}
		      \item Clone Gaussians in under-reconstructed areas:\\
		            Gaussian is small and has high gradient (error): copy gaussians and move them slightly into the gradient direction
		      \item Split large Gaussians in high-detail areas:\\
		            Gaussian is large and has high gradient: split Gaussian into two smaller ones to capture details
		      \item Pruning: Remove Gaussians to prevent floater artifacts and reduce memory usage: \begin{itemize}
			            \item Remove Gaussians with opacity below a certain threshold (contribute little to final image)
			            \item Remove Gaussians that are too small (below a certain radius)
			            \item Remove Gaussians that are too large (above a certain radius)
			            \item Reset Step every $N=3000$ iterations to prevent increase in number of Gaussians
		            \end{itemize}
	      \end{itemize}
\end{itemize}

\begin{center}
	\includegraphics[width=0.8\columnwidth, trim={0 2cm 0 0cm}]{images/3DGS_density_control.jpeg}
	\label{fig:gaussian_splatting_pipeline}
\end{center}


\subsubsection{Rendering Principle}
\begin{enumerate}
	\item \textbf{Projection:} Each 3D Gaussian is projected into the 2D image plane, resulting in an elliptical footprint.
	\item \textbf{Sort Gaussians}: Globally based on depth from camera.
	\item \textbf{Splat}: Compute the shapes of the Gaussian.
	\item \textbf{Alpha Blending}: Perform front-to-back alpha compositing.\\
	      For every pixel, compute the color by walking through the Gaussians from front to back.\\
	      This is simliar to NeRF volume rendering, but instead of sampling along rays, we only consider discretized Gaussians.
\end{enumerate}

\textbf{Advantages:}
\begin{itemize}
	\item NeRF-level quality with real-time rendering.
	\item Fully differentiable projection and blending.
	\item Supports volumetric effects (soft edges, transparency).
	\item Can be optimized end-to-end from images.
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
	\item No explicit surface mesh.
	\item Memory usage can grow with dense scenes.
	\item Topology changes are harder to capture.
\end{itemize}

\subsection{Dynamic Scene Representation}
Make Gaussians move over time:
\textbf{Fixed Parameters}:
\begin{itemize}
	\item Scale
	\item Color
	\item Opacity
\end{itemize}
These get optimized on the first frame and after that stay constant.
\textbf{Time-Varying Parameters}:
\begin{itemize}
	\item 3D Position
	\item 3D Rotation
\end{itemize}
Optimize for each timestep relative to the previous.

\subsection{Surfels vs Gaussians}

\textbf{Surfels}: represent surface discs;
\textbf{Gaussians}: represent smooth volumetric blobs.

\begin{itemize}
	\item Surfels are 2D oriented patches.
	\item Gaussians are 3D ellipsoids that naturally project to 2D.
	\item Surfels require heuristic blending; Gaussians use volumetric accumulation.
	\item Gaussians allow end-to-end differentiable optimization.
\end{itemize}

\begin{center}
	\includegraphics[width=\columnwidth]{images/surface_vs_gaussian.jpeg}
	\label{fig:surface_vs_gaussian}
\end{center}

\textbf{Surface Splatting:}
\begin{itemize}
	\item Primitives represent a solid surface without connected triangle-mesh.
	\item Overlapping surfaces are sorted and blended in depth order
\end{itemize}

\textbf{Volume Splatting (Alpha Compositing):}
\begin{itemize}
	\item Primitives represent fuzzy cloud where light can pass through
	\item Overlapping clouds are blended front-to-back using their opacities (alpha compositing)
\end{itemize}

\subsection{Summary}
\begin{center}
	\includegraphics[width=\columnwidth, trim={0 3cm 0 0.5cm}]{images/gaussian_splatting_hybrid.jpeg}
	\label{fig:gaussian_splatting_hybrid}
\end{center}

\begin{itemize}
	\item Gaussian Splatting can be seen as a hybrid between Neural Radiance Fields and 3D Meshes
	\item Utilizes physics of NeRF for transmittance and blending
	\item Utilizes some of the efficiency of meshes for rendering by rastering, sorting and tiling
\end{itemize}

\textbf{Fundamental Works}\\
\href{https://www.cs.umd.edu/~zwicker/publications/SurfaceSplatting-SIG01.pdf}{Surface Splatting, Zwicker, 2001}
\href{https://arxiv.org/pdf/2308.04079}{3D Gaussian Splatting for Real-Time Radiance Field Rendering, Kerbl, 2023}
